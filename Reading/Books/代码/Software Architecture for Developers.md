# 1. Keypoints
- **架构**
	- 需求驱动架构
	- 架构主要让参与的每个人都能理解、并为产品的成功做出积极贡献
	- 恰如其分的软件架构，一个重要作用就是理解软件系统的重要元素如何结合在一起
	- 结构和愿景
- **敏捷**
	- 以敏捷的方式交付，并不能保证得到的软件架构是敏捷的
	- OODA_loop —— 观察、定向、决策、行动
	- 一个整体系统 & 多个微系统集合 的**权衡** [微服务架构SOA]
	- 理解组织或业务变化的速度决定架构有多敏捷
	- > 架构反映了使一个系统成型的重要设计决策，而重要性则通过改变的成本来衡量

- 理解业务目标、管理架构驱动力
	- 非功能性需求和限制往往对软件架构有巨大的影响；
- 软件设计的一个关键部分是技术选择
- 技术选择就是风险管理

# 2. C4
- 语境、容器、组件、类
	- **类**
		- 最小结构单元
	- **组件**
		- 由类组成的逻辑群组
	- **容器**
		- 在其内部可以执行组件或保存数据的东西
		- 通常是可执行文件
		- 显示技术选择，如何分担责任、通信
	- **系统**
		- 最高的抽象层次
		- 代表了能够提供价值的东西，一般由多个独立的容器构成
		- 包含关键的系统依赖和参与者
	- 虽然不使用 UML 来画图，但是依然要保证以正确的方式记录你的设计；比如箭头线表示依赖还是数据流？UML的箭头意义更加清晰
	- **其他**
		- 流程和工作流
		- 运行时行为
			- 从运行时的角度来呈现系统往往时有用的
			- 使用**协作图**描述特定的用例、特性
		- 域模型
			- 展示最重要的属性和关系
		- 模式和原则
			- 解释如何在代码中实现模式或原则
		- 状态图表
			- 参考 UML 状态图，可视化状态机
		- 部署
			- 参考 UML 部署图
	- 注意事项
		- 必要的**图例**
			- 形状、线条、颜色、边框、缩略词

## 2.1 语境图
- 用来展示你的系统

### 主要成分
- **用户**
	- 业务用户
	- 管理用户
- **系统**
	- 根据不同的环境选择方案

- **交互**
	- 标注用户对系统的交互行为

- **受众**
	- 开发人员、接口人员、非技术人员



## 2.2 容器图
- 系统的整体形态
- 技术决策有哪些？
- 职责分布？
- 容器之间如何交互？
- 新 feature 在哪儿写？

### 主要成分
- **容器**
	- 逻辑上的可执行文件或过程
	- 包括：
		- 名称：逻辑名称
		- 技术：算法、开源库、etc
		- 职责：？
- **交互**
	- 容器间的通信，一般是进程间通信
	- 包括：
		- 交互的目的【任务状态】
		- 通信方法【消息？信号？】
		- 通信方式【同步、异步、批量】
		- 协议
- **系统边界**
	- 如果包含不属于你构建范畴的用户或系统，在适当容器周围用一个**框**，明确系统的边界

## 2.3 组件图
- 主要的逻辑组件及其交互
- 将一个系统实现的功能划分为若干不同的组件、服务、子系统、工作流等
- 描述系统如何工作？是否清晰？

### 主要成分
- **组件**
	- 名称
	- 技术
	- 职责
	- 组件是接口背后的*一组相关行为*，可以用一个或多个协作类实现
	- 组件让我们可以把软件系统看做少数顶层的抽象，而不是组成系统的成百上千个类
	- 高内聚、低耦合、有良好定义的公共接口、良好的封装
	- 软件系统的架构视图和代码之间的映射往往差异巨大，这就是为什么“code never lie”。组件作为一个虚拟结构，在代码中通常以 包、命名空间的形式体现
- **交互**
	- 对标注组件间的交互行为非常重要，而不仅仅是由一堆意义不明的框线组成
	- 交互的目的【使用、存储】
	- 通信方式【同步、异步、批量、阶段等】
- **动机**
	- 组件比类和代码的抽象层次略高
	- 有助于理解系统内部结构
	- 组件图展示了驻留在每个容器中的逻辑组件
		- 将软件系统分解为职责不同的组件
		- 组件之间的关系和依赖
		- 为软件开发的顶层预估和分解交付提供框架
- **技术决策**
	- 分解技术时，通常需要回答以下问题
		- 当前组件如何与其他组件通信
		- 当前组件如何初始化，负责什么？
		- 为什么要使用 XX 技术实现？
	- **技术选择有助于把理想化、概念化的软件设计带回现实，变得脚踏实地**
	- **图应该表达反映现实的抽象**，如果你能明白自己要如何编写代码，就能知道如何可视化

# 3. 文档
- **作用**
	- 软件系统怎样融入已有系统，怎么添加新feature，在哪里添加？
	- 为什么选择正在使用的技术
	- 软件系统的整体结构
	- 部署在哪里？怎样交互？
	- 日志、配置、异常采用哪种方法？
	- 代码库的通用模式和原则
	- 栈安全性是如何实现的
	- 可伸缩性怎样？
	- 与其他系统的接口

# 4. 未归类
- **数据**
	- 数据模型是什么样的？
	- 数据存储在哪儿？
	- 谁拥有数据？
	- 数据需要多少空间？
	- 归档和备份策略？
	- 格式？
- **决策日志**
	- 简单记录重要决策的选择，包括技术选择、整体架构、架构风格、分解、模式等
	- 为什么选择 xx 技术？
	- 怎么知道解决方案满足主要的非功能性需求？
- **自动化测试**
	- 单元测试
		- 对单个类或方法执行的运行快速、非常小的测试
	- 组件测试
		- 未避免破坏组件完整性，仿造外围结构进行测试









