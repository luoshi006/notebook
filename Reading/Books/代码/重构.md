# 重构
- 改善既有代码的设计
- 重构【refactoring】
	- 在不改变代码外在行为的前提下，改进程序的内部结构。就是在代码写好之后改进它的设计。
	- 测试在重构中扮演着非常重要的角色

## 1. 重构，第一个案例
- 如果代码架构使你无法很方便的达成目的，那就先重构那个程序，然后再添加特性；
### 1.2 重构的第一步
- 为即将修改的代码创建一组可靠测试环境
- 测试结果清晰明了，能够直观的反馈测试结果

### 1.3 分解并重组
- 找出代码的逻辑泥团并运用 Extract Method；
- 重构就是以微小的改动修改程序，如果你有错误，很容易就可以发现；
- 绝大多数情况下，函数应该放在它所使用的数据的所属对象内；
- `Replace Temp with Query`
	- 用查询来替换临时变量
	- > 临时变量对于函数来说是只有当前函数可见的，如果你在同类的别的地方要用到这个变量你就必须重新写表达式来获取这个变量，这样的话你就会在不经意间让你的函数**变得复杂**起来
### 1.4 运用多态取代与业务相关的条件逻辑
- `switch` 语句
	- 最好不要在其他对象的属性基础上运用 switch 语句；如果不得不使用，也应该在对象自己的数据上使用；
	- 选择有**不稳定倾向**的类封装业务逻辑，控制业务变更的影响范围；
	- 尽量使用**多态**取代 `switch`语句；也可以考虑状态模式、仲裁者模式
- 数据访问
	- 一般使用 get / set 访问
	- 注意构造函数通过 set 函数初始化，保持接口一致性
- > 所有修改都要使用小步骤迭代，进度看似缓慢，但可以节省 debug 时间，所以整个过程实际上是很快的；
- 重构后的程序风格与过程化风格不同，是结构化风格

## 2. 重构原则
### 2.1 何谓重构
> **重构**：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
- 一种高效的代码整理技术
- 在开发软件时，**添加新功能**和**重构**必须独立进行
	- **添加新功能**：通过测试把控开发进度
	- **重构**：通过测试把控重构正确性
### 2.2 为何重构
- 重构只是工具，而不是银弹
#### 重构改进软件设计
- 代码结构的流失是积累性的。越难看出代码所代表的设计意图，就越难保护其中设计，于是该设计就腐败的越快。
- 消除重复代码
	- 提高可维护性。代码越多，正确的修改就越困难
#### 重构使软件更容易理解
#### 重构帮助找到 bug
#### 重构提高编程速度
- 良好的设计是维持软件开发速度的基础

### 2.3 何时重构
#### 三次法则
- 如果相似的事情多次出现，就需要考虑重构；
#### 添加功能时重构
- 添加功能时，整理代码结构，便于理解新功能
#### 修补错误时重构
- 增加代码可读性，清晰到一眼能看出bug
#### review 代码时重构
> 难以阅读的程序，难以修改
> 逻辑重复的代码，难以修改
> 添加新行为时需要修改已有代码的程序，难以修改
> 带复杂条件逻辑的程序，难以修改
> ---------------
> 容易阅读
> 所有逻辑都只在唯一地点指定
> 新的改动不会危及现有行为
> 尽可能简单表达条件逻辑

### 2.4 怎么对经理说
> 不要告诉经理！

#### 间接层和重构
- 为了模块化，通常会添加间接层将系统拆分。但间接层多了会导致程序越来越难以阅读。
- 间接层的意义
	- 允许逻辑共享
	- 分开解释意图和实现
	- 隔离变化
	- 封装条件逻辑

### 2.5 重构的难题
#### 数据库
- 大多数程序都与其背后的数据库结构紧密耦合在一起；添加一个中间件，可以有效提升代码灵活性；
#### 修改接口
- 接口修改要特别谨慎，如果接口被修改了，任何事情都有可能发生；
- 对于已发布接口，需要同时维护新旧两套接口，直到所有用户对此变化做出响应。
- 让旧接口调用新接口
> - 除非必要，否则不要发布接口
> - 不要过早发布接口
#### 难以通过重构手法完成的设计改动
- 菜鸡
#### 何时不该重构
- 有时候代码太混乱，重构还不如重新写一个；
	- 重写的判断标准：代码根本无法正常工作
	- 折中：将软件系统拆分，再重构子模块
- 临近项目交付期限，尽量不要重构

### 2.6 重构与设计
- 灵活的解决方案复杂度会上升很多；过度的灵活性会使系统的复杂度和维护难度都大大提高。如果最后发现这些灵活性都毫无必要，才是最大的失败。
- 通过重构解决系统灵活性，会更加容易。从而带来简单而不失灵活性的代码设计。
- 基于重构的思想，当下只管建造可运行的最简化系统，置于灵活而复杂的设计，可以在新需求时通过重构嵌入；
- 哪怕你完全了解系统，也请实际测试它的性能，不要臆测；

### 2.7 重构与性能
- 为了让软件易于理解，通常会做出一些使程序变慢的修改
- 首先写出可调的软件，然后调整它以获取足够的性能
- 性能优化应该以实际耗时为准，因为大部分代码都很少会被执行。所以性能优化的前提是性能监控
- 结构良好的程序可以让你有比较充裕的时间进行性能调整；而且在性能分析时，方便以更细粒度的方式度量

### 2.8 重构起源何处
- 语义保持性重构【`semantics-preserving`】

## 3. 代码的坏味道
### 3.1 Duplicated Code 重复代码
- 如果同一个类的两个函数含有相同的表达式，则将重复部分代码抽取成函数；
- 如果两个子类中含有相同或类似表达式，则先抽取重复代码，然后推入父类中；
- 如果两个毫不相关的类出现重复代码，则将重复代码提炼到一个独立类中
### 3.2 Long Method 过长函数
- 拥有短函数的对象会活的更好、更长。短函数引入的间接层会增强代码的解释能力、共享能力、选择能力
- 程序越长越难理解
- 原则：每当感觉需要加点注释来说明点什么的时候，就把需要说明的东西写进一个独立函数中，通过函数名解释
- 关键不在于函数的长度，而在于函数【做什么】与【如何做】之间的语义差距
### 3.3 Large Class 过大的类
- 将几个变量提炼至新类内，提炼时应选择类内彼此相关的变量放在一起；
### 3.4 Long Parameter List 过长参数列表
- 面向对象程序中的函数，参数列表通常比在传统程序中短得多
- 太长的参数列表难以理解，太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它
- `Replace Parameter with Method`
- `Introduce Parameter Object`
- 具体情况具体分析
### 3.5 Divergent Change 发散式变化
- 我们希望软件能够更容易被修改，如果某个类经常因为不同的原因在不同方向上发生变化，
- 针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类中的所有内容都应该反映此变化。为此，你应该找出某特定原因而造成的所有变化，然后将他们提炼到另一个类中。

### 3.6 Shotgun Surgery 散弹式修改
- 如果每遇到某种变化，都必须在许多不同的类内做出许多小修改，就是 `Shotgun Surgery`。
- 通常可以运用 `Inline Class` 把一系列相关行为放进同一个类
- `Divergent Change` 是指一个类受多种变化的影响， `Shotgun Surgery` 则是指一种变化引发多个类相应修改；重构之后的目的是使【外界变化】与【需要修改的类】趋于一一对应关系

### 3.7 Feature Envy 依恋情结
- 面向对象的要点在于：将数据和对数据的操作行为包装在一起。
- `Feature Envy` 是指函数对某个类的兴趣高于对自己所处类的兴趣。
- `Strategy`、`Visitor`、`Self Delegation`
### 3.8 Data Clumps 数据泥团
### 3.9 Primitive Obsession 基本类型偏执
- 面向对象的新手通常不愿意在小人物上运用小对象

### 3.10 Switch Statements
- `switch` 语句的问题在于重复
- `Introduce Null Object`

### 3.11 Parallel Inheritance Hierarchies 平行继承体系
- 每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类

### 3.12 Lazy Class 冗赘类
- 你所创建的每一个类，都得有人取理解、维护，如果一个类不值得去维护，就应该消失。
- `Collapse Hierarchy`, `Inline Class`

### 3.13 Speculative Generality 夸夸其谈未来性
- 企图以各式各样的钩子和特殊情况来处理一些非必要的事情，往往会造成系统更难理解和维护。
- 典型：某些函数或类的唯一用户是测试用例

### 3.14 Temporary Field 令人迷惑的暂时字段
- 某个实例变量仅为某种特定情况而设，这样的代码不易让人理解
- 为这种特定情况创造一个类，并在不使用时，使用 Null Object 避免条件式代码

### 3.15 Message Chains 过度耦合的消息链
- 当代码中出现一长串 `getThis().getThis()...` 或临时变量，意味着代码与查找过程中的导航结构紧密耦合，一旦对象间的关系发生任何变化，代码就不得不做出相应修改
- 先观察消息链最终得到的对象是用来干嘛的，尽量抽取为函数实现

### 3.16 Middle Man 中间人
- 封装——对外部世界隐藏其内部细节。
- 过度使用委托：某个类接口有一半的函数都委托给其他类

### 3.17 Inappropriate Intimacy 狎昵关系
- 继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。

### 3.18 Alternative Classes with Different Interfaces 异曲同工的类
### 3.19 Incomplete Library Class 不完美的库类
### 3.20 Data Class 纯稚的数据类
- Data Class 是指：仅拥有一些数据，以及用于访问的接口
- 要保证数据得到了恰当的封装

### 3.21 Refused Bequest 被拒绝的遗赠
- 子类应该继承父类的函数和数据。
- 子类仅使用部分父类数据和接口，虽然不太优雅，但胡乱修改继承体系更加危险

### 3.22 Comments 过多的注释
- 当你看到一段代码有长长的注释，而注释之所以存在你是因为代码很糟糕

## 4. 构筑测试体系
- 编写优良的测试程序，可以极大的提高编程速度。
### 4.1 自测代码的价值
- 每个类都应该有一个测试函数，并以它来测试自己这个类
- > 确保所有测试都完全自动化，让它们检查自己的测试结果。
- > 自动测试之所以能够帮助快速定位问题，不仅仅因为测试本身，也因为我们频繁的执行测试程序
- 撰写测试代码的最佳时机是在开始编程之前，不仅可以明确功能的具体定义

### 4.2 JUnit 测试框架
#### 单元测试和功能测试
- **单元测试**
	- 目的是为了提高程序员的生产效率
- **功能测试**
	- 从客户的角度保障质量
	- 应该由一个喜欢寻找 Bug 的独立团队来开发，需要使用重量级工具和技术保障功能测试

### 4.3 添加更多测试
- 观察类该做的所有事情，然后针对任何一项功能的任何一种可能失败的情况，进行测试
- 测试应该是一种风险驱动型行为，测试的目的是希望找出现在或未来可能出现的错误
- 测试你最担心出错的部分，这样你就能从测试工作中得到最大利益
- 测试 Tips
	- 寻找边界条件
	- 检查预期的错误是否如期出现
	- 花合理的时间，抓出大多数 Bug

## 5. 重构列表
### 5.1 重构的记录格式
- **Name**
	- 建立重构词汇表
- **Summary**
	- 重构能够帮助解决的问题
	- 介绍你应该做的事
	- 简单介绍重构前后对比【图】
- **Motivation**
	- 为什么需要这个重构
	- 什么情况下不该使用这个重构
- **Mechanics**
	- 步骤
- **Example**
	- case
### 5.2 寻找引用点
- 很多重构都需要你找到某个函数、类、数据的所有引用点。
- **不要盲目的查找-替换，要检查每一个引用点，确定它的确指向你想要替换的东西。**

### 5.3 这些重构手法有多成熟

## 6. 重新组织函数
### 6.1 Extract Method 提炼函数
- 将一段代码放进一个独立函数中，并让函数名称解释该函数的用途
#### 动机
- 过长的函数或者一段需要注释才能让人理解用途的代码，就会将这段代码放进一个独立函数中
- 函数长度不是问题，关键在于函数名称和函数本体之间的语义距离

#### 做法
- 创建一个新函数，并根据实际意图对其命名
- > 如果你想不出一个更有意义的名称，就别动
- 将提炼出的代码复制到新建的目标函数中
- 检查局部变量及作用域，将临时变量处理为查询

### 6.2 Inline Method 内联函数
#### 动机
- 若一个函数的本体与名称一样清晰易懂，则在函数调用的地方插入函数内容，然后移除该函数
- 如果你手上有一群组织不合理的函数，你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。

#### 做法
- 检查函数，确保其不具备多态性
	- 如果子类继承了这个函数，就不能将此函数改为 inline
- 找出这个函数所有被调用点
- 将所有被调用点都替换为函数本体
- 编译、测试
- 删除原函数定义

### 6.3 Inline Temp 内联临时变量
- 只被赋值一次的临时变量
#### 动机
- 临时变量通常会妨碍重构，将所有对该变量的引用动作，替换为对它赋值的表达式本身

### 6.4 Replace Temp with Query 以查询取代临时变量
#### 动机
- 临时变量的问题在于：它们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以**它们会驱使你写出更长的函数**，因为只有这样你才能访问到需要的临时变量。

#### 做法
- 如果临时变量只被赋值一次，参考上一条
- 如果临时变量用来收集某些数据（eg. 循环累加），就需要将某些程序逻辑复制到查询函数
	- 循环累加
		- 将整个循环提炼为一个独立函数
	- 循环累加好几个值
		- 对每个累加值构建一个独立循环查询，就可以抽取出多个独立函数
		- 不要担心性能问题，如果性能真的出了问题，可以在优化期间解决它

### 6.5 Introduce Explaining Variable 引入解释性变量
- 如果有一个复杂的表达式，将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式用途

#### 动机
- 表达式可能非常复杂且难以阅读，这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式
- 然后，将临时变量再抽取为查询私有函数

### 6.6 Split Temporary Variable 分解临时变量


#### 动机
- 如果某个临时变量有多次赋值，既不是循环变量，也不用于收集结果。就意味着临时变量在函数中承担了一个以上的责任
- 同一个临时变量承担两件不同的事情，会让代码阅读困难
- 针对每次赋值，创造一个独立、对应的临时变量

### 6.7 Remove Assignments to Parameters 移除对参数的赋值
#### 动机
- 按值传递的情况下，对参数的任何修改，都不会对调用端造成任何影响。但是会让人理解参数更困难

### 6.8 Replace Method with Method Object 以函数对象取代函数
### 6.9 Substitute ALgorithm 替换算法

## 7. 在对象之间搬移特性
- 类往往会因为承担过多责任而变得臃肿不堪，就需要将一部分责任分离出去
- 如果类变得不负责任，一般会将它融入另一个类

### 7.1 Move Method 搬移函数
#### 动机
- 如果一个类有太多行为，或与另一个类有太多合作而形成高度耦合；通过 `Move Method` 可以使系统中的类更简单

### 7.2 Move Field 搬移字段
#### 动机
- 在类之间移动状态和行为，是重构过程中必不可少的措施。
- 随着系统发展，会发现需要新的类，并需要将现有的工作责任移到新的类中
- 通过编译报错或者运行报错，确保接口已经迁移
- 如果需要对类做许多处理，保持小步前进是必要的

### 7.3 Extract Class 提炼类
#### 动机
- 一个类应该是一个清晰的抽象，处理一些明确的责任
- 在实际工作中，类会不断成长、扩展。给某个类添加一项新职责时，你会觉得不值得为这项责任分离出一个新类。于是，随着责任不断增加，这个类会变得过分复杂
- 这样的类往往含有大量的函数和类，而且也太大不容易理解

### 7.4 Inline Class 将类内联化
#### 动机
- 当一个类不再承担足够责任、不再有单独存在的理由，将其萎缩至最频繁类

### 7.5 Hide Delegate 隐藏委托关系
#### 动机
- 封装意味着每个对象都应该尽可能少的了解系统的其他部分。
- 在对外接口中，尽量少公开类内对象的引用

### 7.6 Remove Middle Man 移除中间人
#### 动机
- 封装要付出的代价，就是每当要添加新特性，就需要添加一个委托函数。随着受托特性越来越多，就需要考虑让外部直接调用受委托类

### 7.7 Introduce Foreign Method 引入外加函数

## 8. 重新组织数据
### 8.1 Self Encapsulate Field 自封装字段
- 类成员变量**[字段]**的访问方式
	- 在类内直接访问
	- 在类内通过访问函数间接访问
	- **选择**
		- 通常会按照团队多数人的意愿选择
		- 优先选择直接访问方式，直到这种方式带来问题为止
- 在构造函数中使用设值函数
	- 一般来说，设值函数被认为应该在对象创建后才使用，所以初始化过程中的行为有可能会出现歧义，需要注意
	- 可以考虑单独建立一个 `initialize` 函数

### 8.2 Replace Data Value with Object 以对象取代数据值
- 当数据值需要相关函数进行特殊行为时，需要谨慎代码坏味道

### 8.3 Change Value to Reference 将值对象改为引用对象
- **引用对象**
	- 具有唯一性，比如人、账户等
	- 需考虑引用对象是请求时创建，还是预先创建
- **值对象**
	- 完全由其所含的数据值来定义，并不在意副本的存在。比如日期、金额

### 8.4 Change Reference to Value 将引用对象改为值对象
- **引用对象**必须被某种方式控制，总是必须向其控制着请求适当的引用对象。可能造成内存区域之间错综复杂的关联
- 在分布式、并发系统中，不可变的**值对象**特别有用，因为无需考虑其同步问题
- 值对象有一个非常重要的特性：它应该是不可变的
	- 如果保证了这一点，就可以放心地以多个对象表示同一个事物。
	- 如果值对象是可变的，就必须确保对某一对象的修改会自动更新其他“代表相同事物”的对象，就不如把它变成引用对象

### 8.5 Replace Array with Object 以对象取代数组
- **数组**：应该只用于“以某种顺序容纳一组相似对象”
- 如果数组中容纳了多种不同对象，或者需要强约束才知道其内容意义时，考虑使用对象将这些信息封装起来，而无需依赖注释

### 8.6 Duplicate Observed Data 复制“被监视数据”
- 一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。
- 将数据与应用分解时，需要提供相应的同步机制

### 8.7 Change Unidirectional Association to Bidirectional 将单向关联改为双向关联
### 8.8 Change Bidirectional Association to Unidirectional 将双向关联改为单向关联
- 双向关联使两个类之间有了依赖；会构成紧耦合系统，任何一点改动都可能造成许多无法预知的后果
- 难点在于检查可行性

### 8.9 Replace Magic Number with Symbolic Constant 以字面常量取代魔法数
### 8.10 Encapsulate Field 封装字段
- `public` 字段会降低程序的模块化程度

### 8.11 Encapsulate Collection 封装集合
- 如果一个函数返回一个集合，让这个函数返回该集合的一个只读副本，并在这个类中提供添加、删除元素的函数
- 不应该为整个集合提供设值函数，但应该提供添加、删除元素的函数。

### 8.12 Replace Record with Data Class 以数据类取代记录
### 8.13 Replace Type Code with Class 以类取代类型码
- 类型码或枚举值，编译器通常只对它背后的数值进行校验，可能引起歧义
- 强类型枚举

### 8.14 Replace Type Code with Subclasses 以子类取代类型码
- 把“了解不同行为”从类用户转移到了类自身，如果需要再加入新的行为变化，只需添加一个子类

### 8.15 Replace Type Code with State/Strategy 以 State/Strategy 取代类型码
- 与子类化相似，如果“类型码的值在对象生命周期中发生变化”或“其他原因使得宿主类不能被继承”，可以使用状态机或策略模式代替

### 8.16 Replace Subclass with Fields 以字段取代子类
- 如果各个子类之间的区别只有“常量函数”，返回一个硬编码的字符串。考虑在父类中使用字段表示，删除子类，避免因继承带来的复杂度

## 9. 简化条件表达式
### 9.1 Decompose Conditional 分解条件表达式
- 复杂的条件逻辑是最常导致复杂度上升的场景之一
- 尽管有时候条件判断很短，在代码意图和代码自身之间往往存在不小的差距。使用函数封装可以提升代码可读性

### 9.2 Consolidate Conditional Expression 合并条件表达式
- 如果前后两个条件判断中，检查条件不一样，执行部分一样，就应该使用 “或、与”将它们合并为一个条件表达式
- 将检查条件提炼为一个独立函数对厘清代码非常有用，因为它把描述做什么的语句换成了为什么

### 9.3 Consolidate Duplicate Conditional Fragments 合并重复的条件片段
### 9.4 Remove Control Flag 移除控制标记
- 优先使用 return，其次是 break、continue，因为 return 能够清晰的表示：不再执行该函数的其他任何代码

### 9.5 Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套条件表达式
- 条件表达式通常有两种形式
	- 所有分支都属于正常行为
	- 条件表达式提供的答案中只有一种是正常行为，其他都是不常见的情况
- **卫语句 guard clauses**
	- 如果某个条件不常见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回
	- `if..else..` 结构中，两个分支有同样的重要性；在卫语句中，表示这种情况很特殊，需要做一些必要的处理，然后退出

### 9.6 Replace Conditional with Polymorphism 以多态取代条件表达式
- 多态可以根据对象的不同类型而采取不同的行为，能够替代显式的条件表达式

### 9.7 Introduce Null Object 引入 Null 对象
- 多态不需要再查询类型，而后根据得到的类型调用对象的某个行为
- 空对象可以摆脱 null 检查
- 系统不会因为空对象而被破坏，由于空对象对外界请求的相应和实体对象保持一致，所以系统行为总是正常的
- 空对象一定是常量，其任何成分都不会发生变化，可以使用 singleton 模式
- Special Case 模式，对某些特殊情况，定义特殊行为

### 9.8 Introduce Assertion 引入断言
- 如果一段代码需要对程序状态做出某种假设，以断言明确表现这种假设
- 断言如果失败，表示程序员犯了错。因此断言失败应该导致一个非受控异常 [unchecked exception]
- 程序最后的成品往往将断言删除
- 断言可以作为交流和调试的辅助方法
- **注意，不要滥用断言。请不要使用它来检查“你认为应该为真”的条件，只用断言检查“一定必须为真”的条件**

## 10. 简化函数调用
- 容易被理解和被使用的接口，是开发良好面向对象软件的关键。
- 良好的接口只向用户展现必须展现的东西
- 所有数据都应该隐藏起来
- 不习惯使用异常的程序员，往往会以错误码表示程序遇到的麻烦

### 10.1 Rename Method 函数改名
- 将复杂的处理过程分解成小函数，关键就在于函数名应该准确表达它的用途
- 想要成为一个真正的编程高手，起名的水平是至关重要的

### 10.2 Add Parameter 添加参数
- 过长的参数列表是不好的味道

### 10.3 Remove Parameter 移除参数
- 程序员可能经常添加参数，却往往不愿意去掉它们
- 参数代表着函数所需的信息，不同参数值有不同的意义。

### 10.4 Separate Query from Modifier 将查询函数和修改函数分离
- 任何有返回值的函数，都不应该有看得到的副作用
- 在多线程系统中，需要保证查询和修改的同步操作，可以使用第三个函数来同时操作“查询-修改”，并保证数据同步

### 10.5 Parameterize Method 令函数携带参数
- 若有两个函数，做着类似的工作，但因为少数几个值导致行为略有不同。可以将函数统一起来，并通过参数来处理不同情况

### 10.6 Replace Parameter with Explicit Methods 以明确函数取代参数
- 若有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立函数
- 可以避免出现条件表达式，同时使接口更清晰；

### 10.7 Preserve Whole Object 保持对象完整
- 如果需要从某个对象中取出若干值，改为传递整个对象
- 可以使参数列更稳定，还能提高代码可读性；是所需参数在对象中的占比而定

### 10.8 Replace Parameter with Methods 以函数取代参数
- 如果函数可以通过其他途径获得参数值，那么它就不应该通过参数取得该值；过长的参数列会增加程序阅读的难度，因此我们应该尽可能缩短参数列的长度

### 10.9 Introduce Parameter Object 引入参数对象
- 某些参数总是很自然地同时出现，以一个对象取代这些参数
	- 时间范围：start -> end
	- 数值范围：upper -> lower
- 目的在于缩短参数列表

### 10.10 Remove Setting Method 移除设值函数
- 如果为某个字段提供了设值函数，就暗示这个字段值可以被改变
- 如果不希望在对象创建之后再改变该字段，就不要为其提供设值函数

### 10.11 Hide Method 隐藏函数
- 重构往往促使你修改函数的可见度
- 当面对一个过于丰富、提供了过多行为的接口时，就值得将非必要的取值函数和设值函数隐藏起来。

### 10.12 Replace Constructor with Factory Method 以工厂函数取代构造函数
- 工厂函数可以根据类型码返回子类对象

### 10.13 Encapsulate Downcast 封装向下转型
### 10.14 Replace Error Code with Exception 以异常取代错误码
- 如果程序崩溃的代价很小，程序出错后终止即可
- 程序中发现错误的地方，并不一定知道如何处理错误。所以需要其调用者知道这个错误，逐级上报
- 使用异常上报，能够清晰的将“普通程序”和“错误处理”分开
- 首先需要决定“受控异常”还是“非受控异常”，决策关键在于责任划分

### 10.15 Replace Exception with Test 以测试取代异常
- 可以通过预检查，防止抛出异常
- 异常可以协助我们避免很多复杂的错误处理逻辑；异常只应该被用于异常的、罕见的行为，也就是**意料之外**的行为，而不应该成为条件检查的替代品。

## 11. 处理概括关系
- 概括关系（generalization，即继承关系）
- 主要是将函数上下移动于继承体系之中

### 11.1 Pull Up Field 字段上移
- 两个子类有相同的字段，移至父类

### 11.2 Pull Up Method 函数上移
- 有些函数，在各个子类中产生完全相同的结果，将该函数移至超类

### 11.3 Pull Up Constructor Body 构造函数本体上移
- 各个子类中的构造函数基本一致，则移至父类，并在子类中调用

### 11.4 Push Down Method 函数下移
- 父类中某个函数只与部分子类有关，则移到相关的子类去

### 11.5 Push Down Field 字段下移
- 父类中的某个字段只有部分子类用到，将这个字段移到需要它的子类中

### 11.6 Extract Subclass 提炼子类
- 类中的某些特性只被某些实例用到；考虑新建一个子类，将这部分特性移到子类中

### 11.7 Extract Superclass 提炼超类
- 两个类有相似特性，为这两个类建立一个超类，将相同特性移至超类

### 11.8 Extract Interface 提炼接口
- 若干客户使用类接口中的同一子集，将相同的子集提炼到一个独立接口中
- 多继承

### 11.9 Collapse Hierarchy 折叠继承体系
- 超类和子类之间没有太大区别，将它们合为一体

### 11.10 Form Template Method 塑造模板函数
- 将两个相似函数提升到超类，并借助多态保证各操作仍得以保持差异性

### 11.11 Replace Inheritance with Delegation 以委托取代继承
- 如果子类只使用超类接口中的一部分，在子类中新建字段用以保存超类数据，然后将继承改为委托

### 11.12 Replace Delegation with Inheritance 以继承取代委托
- 如果需要使用受托类中的所有函数，并编写委托函数；考虑使用继承

## 12 大型重构
- 大型重构会耗费相当长的时间，需要数月甚至数年的时间
- 在这个过程中，应该根据需要安排自己的工作，只在需要添加新功能或修补错误时才进行重构。不必一开始就完成整个系统的重构，重构程序只要能满足其他任务的需求即可
- 进行大规模重构时，有必要为整个开发团队建立共识：“有一个大型重构正在进行，每个人都应该相应地安排自己的行动”
- 在一知半解的情况下做出的设计决策，一旦堆积起来，也会使你的程序陷于瘫痪；通过重构，可以保证随时在程序中反映出完整的设计思路

### 12.1 Tease Apart Inheritance 梳理并分解继承体系
- 某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个
- 混乱的继承体系是一个严重的问题，会使代码非常难以理解。

### 12.2 Convert Procedural Design to Objects 将过程化设计转换为对象设计
### 12.3 Separate Domain from Presentation 将领域和表述/显示分离
- 参考 MVC模式【模型-视图-控制器】

### 12.4 Extract Hierarchy 提炼继承体系
- 若某个类做了太多工作，其中一部分工作是以大量条件表达时候完成的；建立继承体系，以一个子类表示一种特殊情况

## 13 重构，复用与现实
### 13.1 现实的检验
### 13.2 为什么开发者不愿意重构他们的程序
- Fred Brooks: "应对并处理变化，是软件开发的根本复杂性之一"

#### 如何重构，在哪里重构
- 一个常见的重构原因，是调整程序结构以使添加新功能更容易
- 几种好的程序结构性质量和特征能够为可扩展性和可复用性提供支持
- 自动化工具可用来识别程序中的结构缺陷，例如参数过多、函数过长、代码重复
- 从C到C++的移植不可能由面向对象程序员来进行，只能有C程序员来做
- 大多数面向对象程序员都会避免使用**指针运算**
- 重构的意义在于程序员和程序开发团队图和开发并维护自己的软件

### 13.3 再论现实的检验
### 13.4 重构的资源和参考资料
### 13.5 从重构联想到软件复用和技术传播
## 14 重构工具
### 14.1 使用工具进行重构
### 14.2 重构工具的技术标准
### 14.3 重构工具的实用标准
## 15 总结
- 大规模的重构只会带来灾难

















